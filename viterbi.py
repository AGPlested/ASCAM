import matplotlib.pyplot as plt
import numpy as np

n_samples = 10
n_states = 3
states = np.random.randint(low=0, high=n_states, size=n_samples)
noise = np.sqrt(0.2)*np.random.randn(n_samples)
obs = states + noise

# only works in n_states==3
# We should use something generic for testing.
initial_dist = np.array([0.2, 0.3, 0.5])
# But realistically we know in which state the system beings (i.e. the
# closed state).
# initial_dist = np.array([1, 0, 0])

# Assuming the states are 1-dimensional. This will be true in practice.
def normal_pdf(x, mu=0, sigma=1):
    return np.exp(-0.5 * ((x-mu)/sigma)**2) / (np.sqrt(2*np.pi) * sigma)

"""Compute the probability of each observation being generated by each
   state.
   Input:
    observations = N×1 array
    components = K×3 array
   N = Length of observations
   K = Number of states
"""
def compute_emission_matrix(observations, components):
    n_obs = len(observations)
    n_states = np.shape(components)[0]
    emission_matrix = np.zeros((n_states, n_obs))
    for i in range(n_states):
        mu = components[i,1]
        sigma = components[i,2]
        emission_matrix[i,:] = normal_pdf(observations, mu=mu, sigma=sigma)
    # Return the normalized matrix
    return emission_matrix/np.sum(emission_matrix, axis=1, keepdims=True)

components = np.array([[0.4, 0, 0.1],
                       [0.3, 1, 0.1],
                       [0.3, 2, 0.1]])

EM = compute_emission_matrix(obs, components)

def empirical_transition_matrix(trajectory, n_states):
    """Compute the transition matrix of a Markov chain based on a
       realization thereof.
       Input:
        trajectory = N×1 array with states assigned integer values in [0, K)
       N = Length of sample
       K = Number of states
    """
    transition_matrix = np.zeros((n_states, n_states))
    for i in range(len(trajectory)-1):
        transition_matrix[trajectory[i], trajectory[i+1]] += 1
    # If any states are never exited add small noise to the matrix to avoid
    # diving by zero.
    if np.any(np.sum(transition_matrix, axis=1)==0):
        transition_matrix += 1e-6
    # Return the normalized matrix
    return transition_matrix/np.sum(transition_matrix, axis=1,
                                    keepdims=True)

transition_matrix = empirical_transition_matrix(states, n_states)
