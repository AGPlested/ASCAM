import os
import tempfile

import pytest
import numpy as np
from PySide2.QtWidgets import QApplication
from PySide2.QtCore import Qt
from scipy.stats import truncnorm

from src.core import Recording
from src.constants import TEST_FILE_NAME
from src.core.DISC import sample_chain
from src.gui.mainwindow import MainWindow


@pytest.fixture(scope="session")
def test_app():
    app = QApplication([])
    yield app
    app.quit()

@pytest.fixture(scope="class")
def main_window(test_app, recording):
    main_window = MainWindow(screen_resolution=(1920, 1080))
    main_window.data = recording
    return main_window

def path_to_ascam_file(*args):
    path = os.path.split( os.path.dirname(os.path.abspath(__file__)) )[0]
    return os.path.join(path, *args)

@pytest.fixture(scope="class")
def recording():
    """Note: This fixture is only run once for all tests in a class.
    It can therefore be modified by the tests and their order might be important.
    This fixture is overwritte in the test_idealization_cache.py module. If you
    make any changes here check if they should be applied there as well"""
    TEST_FILE = path_to_ascam_file("data", TEST_FILE_NAME)
    return Recording.from_file(TEST_FILE, 4e4)

@pytest.fixture(scope="class")
def csv_data():
    """This csv file was generated by ASCAM (commot 8f4f6a0) from the
    example data with the parameters loaded in test-mode."""
    filepath = path_to_ascam_file("data", "test.csv")
    with open(filepath, "r") as f:
        header = f.readline()
        header += f.readline()
    data = np.loadtxt(filepath, skiprows=1, delimiter=",")
    return header, data

@pytest.fixture(scope="class")
def mat_save_file():
    _, temp_file_name = tempfile.mkstemp()
    return temp_file_name+".mat"

@pytest.fixture(scope="class")
def TM():
    """This is the transition matrix used in the example data.
    The values are based on private correspondence with chatgpt."""

    return np.array([[0.7, 0.1, 0.1, 0.05, 0.05],
                     [0.1, 0.7, 0.1, 0.05, 0.05],
                     [0.1, 0.1, 0.7, 0.05, 0.05],
                     [0.05, 0.05, 0.05, 0.7, 0.15],
                     [0.05, 0.05, 0.05, 0.15, 0.7]])

@pytest.fixture()
def true_signal(TM):
    def _f(n_samples=100):
        np.random.seed(0)
        return sample_chain(TM, 4, n_samples)
    return _f

@pytest.fixture()
def time():
    def _f(sampling_rate=4e4, n_samples=100):
        return np.arange(n_samples)/sampling_rate
    return _f

@pytest.fixture()
def signal_trunc_noise(true_signal):
    """Return a noisy signal with noise following a truncated normal
    distribution. The noise should be set to be less than the smallest
    difference between a state in the true signal (integer valued in
    steps of 1) and a threshold.
    Use by adding the decorator
    @pytest.mark.signal_trunc_noise(noise_limit=0.49)
    to the test function and then pass signal_trunc_noise as an
    argument to the function.
    """
    def _f(noise_limit=0.49, n=100):
        np.random.seed(1)
        return true_signal(n) + truncnorm.rvs(-noise_limit, noise_limit,
                                           size=true_signal(n).shape)
    return _f

def get_states(true_CP, n_samples=100):
    """Get a vector that is 1 for the first `true_CP` samples and 0 for the rest."""
    return np.concatenate((np.ones(true_CP+1), np.zeros(n_samples-true_CP-1)))

def get_test_data(CPs, n_samples=100):
    """Given a vector of changepoints or a list of such vectors return a list of
    tuples (cps, data) where cps is the changepoints and data is the signal.
    The signal has two states 1 and 0."""
    if type(CPs[0]) == int:
        out = [(cp, get_states(cp)) for cp in CPs]
    else:
        out = []
        for cps in CPs:
            data = np.ones(n_samples)
            for cp in cps:
                data[cp+1:-1] = (data[cp]+1)%2
            data[-1] = data[-2]
            out.append((cps, data))
    return out

def clear_text_edit(qtbot, text_edit):
    """Clear a text edit widget by selecting all text and pressing backspace."""
    qtbot.mouseClick(text_edit, Qt.LeftButton)
    qtbot.keyPress(text_edit, Qt.Key_A, Qt.ControlModifier)
    qtbot.keyPress(text_edit, Qt.Key_Backspace)

