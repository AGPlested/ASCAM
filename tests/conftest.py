import os

import pytest
import tempfile
import numpy as np
from PySide2.QtWidgets import QApplication
from scipy.stats import truncnorm

from src.core import Recording
from src.constants import TEST_FILE_NAME
from src.core.DISC import sample_chain
from src.gui.mainwindow import MainWindow


@pytest.fixture(scope="class")
def recording():
    path = os.path.split( os.path.dirname(os.path.abspath(__file__)) )[0]
    path = os.path.join(path, "data")
    TEST_FILE = os.path.join(path, TEST_FILE_NAME)
    return Recording.from_file(TEST_FILE, 4e4)

@pytest.fixture(scope="class")
def main(recording):
    QApplication([])
    main_window = MainWindow(screen_resolution=(1920, 1080))
    main_window.data = recording
    return main_window

def path_to_ascam_file(*args):
    path = os.path.split( os.path.dirname(os.path.abspath(__file__)) )[0]
    return os.path.join(path, *args)

@pytest.fixture(scope="class")
def recording():
    """Note: This fixture is only run once for all tests in this class.
    It can therefore be modified by the tests and their order might be important."""
    TEST_FILE = path_to_ascam_file("data", TEST_FILE_NAME)
    return Recording.from_file(TEST_FILE, 4e4)

@pytest.fixture(scope="class")
def csv_data():
    """This csv file was generated by ASCAM (commot 8f4f6a0) from the
    example data with the parameters loaded in test-mode."""
    filepath = path_to_ascam_file("data", "test.csv")
    with open(filepath, "r") as f:
        header = f.readline()
        header += f.readline()
    data = np.loadtxt(filepath, skiprows=1, delimiter=",")
    return header, data

@pytest.fixture(scope="class")
def mat_save_file():
    _, temp_file_name = tempfile.mkstemp()
    return temp_file_name+".mat"

@pytest.fixture(scope="class")
def TM():
    """This is the transition matrix used in the example data.
    The values are based on private correspondance with chatgpt."""
    return np.array([[0.0, 0.59, 0.22, 0.11, 0.08],
              [0.03, 0.0, 0.67, 0.15, 0.15],
              [0.07, 0.16, 0.0, 0.63, 0.14],
              [0.03, 0.15, 0.18, 0.0, 0.64],
              [0.11, 0.11, 0.11, 0.11, 0.56]])

@pytest.fixture()
def true_signal(TM):
    def _f(n_samples=100):
        np.random.seed(0)
        return sample_chain(TM, 4, n_samples)
    return _f

@pytest.fixture()
def time():
    def _f(sampling_rate=4e4, n_samples=100):
        return np.arange(n_samples)/sampling_rate
    return _f

@pytest.fixture()
def signal_trunc_noise(true_signal):
    """Return a noisy signal with noise following a truncated normal
    distribution. The noise should be set to be less than the smallest
    difference between a state in the true signal (integer valued in
    steps of 1) and a threshold.
    Use by adding the decorator
    @pytest.mark.signal_trunc_noise(noise_limit=0.49)
    to the test function and then pass signal_trunc_noise as an
    argument to the function.
    """
    def _f(noise_limit=0.49, n=100):
        np.random.seed(1)
        return true_signal(n) + truncnorm.rvs(-noise_limit, noise_limit,
                                           size=true_signal(n).shape)
    return _f
